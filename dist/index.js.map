{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap a79059a65a266adffb7d","webpack:///./src/MobxPromise.ts","webpack:///external \"mobx\"","webpack:///./src/index.ts","webpack:///./src/utils.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"mobx\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"mobx\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"index\"] = factory(require(\"mobx\"));\n\telse\n\t\troot[\"index\"] = factory(root[\"mobx\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a79059a65a266adffb7d","import {observable, action, computed, makeObservable} from \"mobx\";\n\n/**\n * This tagged union type describes the interoperability of MobxPromise properties.\n */\ntype MobxPromiseStatus = 'pending' | 'error' | 'complete';\nexport type MobxPromiseUnionType<R> = (\n    { status: 'pending', isPending: true, isError: false, isComplete: false, result: R | undefined, error: Error | undefined } |\n    { status: 'error', isPending: false, isError: true, isComplete: false, result: R | undefined, error: Error } |\n    { status: 'complete', isPending: false, isError: false, isComplete: true, result: R, error: Error | undefined }\n    ) & { peekStatus: MobxPromiseStatus };\nexport type MobxPromiseUnionTypeWithDefault<R> = (\n    { status: 'pending', isPending: true, isError: false, isComplete: false, result: R, error: Error | undefined } |\n    { status: 'error', isPending: false, isError: true, isComplete: false, result: R, error: Error } |\n    { status: 'complete', isPending: false, isError: false, isComplete: true, result: R, error: Error | undefined }\n    ) & { peekStatus: MobxPromiseStatus };\n\nexport type MobxPromiseInputUnion<R> = PromiseLike<R> | (() => PromiseLike<R>) | MobxPromiseInputParams<R>;\nexport type MobxPromiseInputParams<R> = {\n    /**\n     * A function that returns a list of MobxPromise objects which are dependencies of the invoke function.\n     */\n    await?: MobxPromise_await,\n\n    /**\n     * A function that returns the async result or a promise for the async result.\n     */\n    invoke: MobxPromise_invoke<R>,\n\n    /**\n     * Default result in place of undefined\n     */\n    default?: R,\n\n    /**\n     * A function that will be called when the latest promise from invoke() is resolved.\n     * It will not be called for out-of-date promises.\n     */\n    onResult?: (result?: R) => void,\n\n    /**\n     * A function that will be called when the latest promise from invoke() is rejected.\n     * It will not be called for out-of-date promises.\n     */\n    onError?: (error: Error) => void,\n};\nexport type MobxPromise_await = () => Array<MobxPromiseUnionTypeWithDefault<any> | MobxPromiseUnionType<any> | MobxPromise<any>>;\nexport type MobxPromise_invoke<R> = () => PromiseLike<R>;\nexport type MobxPromiseInputParamsWithDefault<R> = {\n    await?: MobxPromise_await,\n    invoke: MobxPromise_invoke<R>,\n    default: R,\n    onResult?: (result: R) => void,\n    onError?: (error: Error) => void,\n};\n\n/**\n * MobxPromise provides an observable interface for a computed promise.\n * @author adufilie http://github.com/adufilie\n */\nexport class MobxPromiseImpl<R> {\n    static isPromiseLike(value: any) {\n        return value != null && typeof value === 'object' && typeof value.then === 'function';\n    }\n\n    static normalizeInput<R>(input: MobxPromiseInputParamsWithDefault<R>): MobxPromiseInputParamsWithDefault<R>;\n    static normalizeInput<R>(input: MobxPromiseInputUnion<R>, defaultResult?: R): MobxPromiseInputParamsWithDefault<R>;\n    static normalizeInput<R>(input: MobxPromiseInputUnion<R>): MobxPromiseInputParams<R>;\n    static normalizeInput<R>(input: MobxPromiseInputUnion<R>, defaultResult?: R) {\n        if (typeof input === 'function')\n            return {invoke: input, default: defaultResult};\n\n        if (MobxPromiseImpl.isPromiseLike(input))\n            return {invoke: () => input as PromiseLike<R>, default: defaultResult};\n\n        input = input as MobxPromiseInputParams<R>;\n        if (defaultResult !== undefined)\n            input = {...input, default: defaultResult};\n        return input;\n    }\n\n    constructor(input: MobxPromiseInputUnion<R>, defaultResult?: R) {\n\n        makeObservable<MobxPromiseImpl<R>>(this);\n\n        let norm = MobxPromiseImpl.normalizeInput(input, defaultResult);\n        this.await = norm.await;\n        this.invoke = norm.invoke;\n        this.defaultResult = norm.default;\n        this.onResult = norm.onResult;\n        this.onError = norm.onError;\n    }\n\n    private await?: MobxPromise_await;\n    private invoke: MobxPromise_invoke<R>;\n    private onResult?: (result?: R) => void;\n    private onError?: (error: Error) => void;\n    private defaultResult?: R;\n    private invokeId: number = 0;\n    private _latestInvokeId: number = 0;\n\n    @observable private internalStatus: 'pending' | 'complete' | 'error' = 'pending';\n    @observable.ref private internalResult?: R = undefined;\n    @observable.ref private internalError?: Error = undefined;\n\n    @computed get status(): 'pending' | 'complete' | 'error' {\n        // wait until all MobxPromise dependencies are complete\n        if (this.await)\n            for (let status of this.await().map(mp => mp.status)) // track all statuses before returning\n                if (status !== 'complete')\n                    return status;\n\n        let status = this.internalStatus; // force mobx to track changes to internalStatus\n        if (this.latestInvokeId != this.invokeId)\n            status = 'pending';\n        return status;\n    }\n\n    @computed get peekStatus(): 'pending' | 'complete' | 'error' {\n        // check status without triggering invoke\n\n        // check status of all MobxPromise dependencies\n        if (this.await)\n            for (let status of this.await().map(mp => mp.peekStatus))\n                if (status !== 'complete')\n                    return status;\n\n        // otherwise, return internal status\n        return this.internalStatus;\n    }\n\n    @computed get isPending() {\n        return this.status == 'pending';\n    }\n\n    @computed get isComplete() {\n        return this.status == 'complete';\n    }\n\n    @computed get isError() {\n        return this.status == 'error';\n    }\n\n    @computed get result(): R | undefined {\n        // checking status may trigger invoke\n        if (this.isError || this.internalResult == null)\n            return this.defaultResult;\n\n        return this.internalResult;\n    }\n\n    @computed get error(): Error | undefined {\n        // checking status may trigger invoke\n        if (!this.isComplete && this.await)\n            for (let error of this.await().map(mp => mp.error)) // track all errors before returning\n                if (error)\n                    return error;\n\n        return this.internalError;\n    }\n\n    /**\n     * This lets mobx determine when to call this.invoke(),\n     * taking advantage of caching based on observable property access tracking.\n     */\n    @computed\n    private get latestInvokeId() {\n        window.clearTimeout(this._latestInvokeId);\n        let promise = this.invoke();\n        let invokeId: number = window.setTimeout(() => this.setPending(invokeId, promise));\n        return this._latestInvokeId = invokeId;\n    }\n\n    @action\n    private setPending(invokeId: number, promise: PromiseLike<R>) {\n        this.invokeId = invokeId;\n        promise.then(\n            result => this.setComplete(invokeId, result),\n            error => this.setError(invokeId, error)\n        );\n        this.internalStatus = 'pending';\n    }\n\n    @action\n    private setComplete(invokeId: number, result: R) {\n        if (invokeId === this.invokeId) {\n            this.internalResult = result;\n            this.internalError = undefined;\n            this.internalStatus = 'complete';\n\n            if (this.onResult)\n                this.onResult(this.result); // may use defaultResult\n        }\n    }\n\n    @action\n    private setError(invokeId: number, error: Error) {\n        if (invokeId === this.invokeId) {\n            this.internalError = error;\n            this.internalResult = undefined;\n            this.internalStatus = 'error';\n\n            if (this.onError)\n                this.onError(error);\n        }\n    }\n}\n\nexport type MobxPromiseFactory = {\n    // This provides more information for TypeScript code flow analysis\n    <R>(input: MobxPromiseInputParamsWithDefault<R>): MobxPromiseUnionTypeWithDefault<R>;\n    <R>(input: MobxPromiseInputUnion<R>, defaultResult: R): MobxPromiseUnionTypeWithDefault<R>;\n    <R>(input: MobxPromiseInputUnion<R>): MobxPromiseUnionType<R>;\n};\n\nexport const MobxPromise = MobxPromiseImpl as {\n    // This provides more information for TypeScript code flow analysis\n    new<R>(input: MobxPromiseInputParamsWithDefault<R>): MobxPromiseUnionTypeWithDefault<R>;\n    new<R>(input: MobxPromiseInputUnion<R>, defaultResult: R): MobxPromiseUnionTypeWithDefault<R>;\n    new<R>(input: MobxPromiseInputUnion<R>): MobxPromiseUnionType<R>;\n};\n\nexport interface MobxPromise<T> extends Pick<MobxPromiseImpl<T>, 'status' | 'error' | 'result' | 'isPending' | 'isError' | 'isComplete' | 'peekStatus'> {\n}\n\nexport default MobxPromise;\n\n\n\n// WEBPACK FOOTER //\n// ./src/MobxPromise.ts","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"mobx\"\n// module id = 1\n// module chunks = 0","export * from './MobxPromise';\nexport * from './utils';\n\nimport MobxPromise from './MobxPromise';\nexport default MobxPromise;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.ts","import {autorun, computed, getObserverTree, IComputedValue, IListenable, IObservable,\n_getAdministration, getAtom} from 'mobx';\nimport {MobxPromise} from \"./MobxPromise\";\n\n/**\n * A decorator for creating a <code>@computed</code> property that will be cached\n * after the first time it is accessed, even if it becomes unobserved later.\n * @param target\n * @param propertyKey\n * @param descriptor\n */\nexport function cached<T>(target: any, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<T>)\n{\n\tif (descriptor.get)\n\t{\n\t\tlet get = descriptor.get;\n\t\tdescriptor.get = function(...args:any[]) {\n\t\t\tconst atom = getAtom(this, propertyKey as string) as IObservable & IListenable;\n\t\t\t// to keep the cached value, add an observer if there are none\n\t\t\tif (!atom.isBeingObserved_)\n\t\t\t\tautorun(()=>atom);\n\n\t\t\treturn get.apply(this, args);\n\t\t};\n\t}\n\treturn descriptor;\n}\n\n/**\n * Checks if a property has observers.\n */\nexport function hasObservers<T>(thing:T, property:keyof T)\n{\n\tlet tree = getObserverTree(thing, property as string);\n\treturn tree && tree.observers ? tree.observers.length > 0 : false;\n}\n\n/**\n * Update MobxPromise debug names to reflect their property names on a given object.\n * @param target An object which has properties that are MobxPromises.\n */\nexport function labelMobxPromises<T extends object>(target:T)\n{\n\tfor (let key in target)\n\t{\n\t\tlet desc = Object.getOwnPropertyDescriptor(target, key);\n\t\tif (desc && desc.value instanceof MobxPromise)\n\t\t{\n\t\t\tlet admin = _getAdministration(desc.value);\n\t\t\tadmin.name = `${key}(${admin.name})`;\n\t\t}\n\t}\n}\n\n/**\n * A function created with debounceAsync() returns a new Promise\n * every time, but only the last promise created before invoking the\n * original function will be resolved after a specified delay.\n */\nexport function debounceAsync<R, F extends (...args:any[]) => PromiseLike<R>>(invoke:F, delay = 0):F\n{\n\tfunction invokeLater(\n\t\tcontext:any,\n\t\targs:any[],\n\t\tresolve:(result:PromiseLike<R>)=>void,\n\t\treject:(error:Error)=>void\n\t) {\n\t\ttry\n\t\t{\n\t\t\tresolve(invoke.apply(context, args));\n\t\t}\n\t\tcatch (e)\n\t\t{\n\t\t\treject(e);\n\t\t}\n\t}\n\n\tlet timeout = 0;\n\treturn function(...args:any[]):PromiseLike<R> {\n\t\treturn new Promise<R>(\n\t\t\tfunction(resolve, reject) {\n\t\t\t\twindow.clearTimeout(timeout);\n\t\t\t\ttimeout = window.setTimeout(invokeLater, delay, this, args, resolve, reject);\n\t\t\t}\n\t\t);\n\t} as F;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.ts"],"sourceRoot":""}